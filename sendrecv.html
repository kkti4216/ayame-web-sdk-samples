<html lang="ja">
    <head>
        <meta charset="utf-8">
        <title>Ayame Send/Recv Sample</title>
        <link rel="stylesheet" href="https://cdn.rawgit.com/Chalarangelo/mini.css/v3.0.1/dist/mini-default.min.css">
    </head>
    <body>
      <header class="sticky row">
      <h4>Ayame Send/Recv Sample</h4>
      </header>
      <div>
        <p>Signaling Server
          <input id="signalingURLnput" type="text" value=""></input>
        </p>
        <p>Room ID
        <input id="roomIdInput" type="text"></input>
        </p>
        <p>Client ID
        <input id="clientIdInput" disabled type="text" value=""></input>
        </p>
        <!-- <p> Codec
        <select id="video-codec" onChange="onChangeVideoCodec();">
          <option value="H264">H264</option>
          <option value="none">none</option>
          <option value="VP8">VP8</option>
          <option value="VP9">VP9</option>
          <option value="AV1">AV1</option>
          <option value="H265">H265</option>
        </select>
        </p> -->
        <!-- <p> Size
        <select id="video-size">
          <option value="1080p-v">1080p-v</option>
          <option value="1080p-h">1080p-h</option>
          <option value="480p">480p</option>
        </select>
        </p> -->
        <button id="connect">Connect</button>
        <button id="disconnect" disabled>Disconnect</button>
        <button id="start-recording">Start Recording</button>
        <button id="stop-recording" disabled>Stop Recording</button>
        <p>Total stream duration: <span id="call-duration">0</span> seconds</p>
         <a id="download-link-remote" href="#" download="remote-video.webm" style="display:none">Download Remote Video</a>
         <a id="download-link-local" href="#" download="local-video.webm" style="display:none">Download Local Video</a>
      </div>
      <div style="float:left;">
        <video id="local-video" muted autoplay playsinline style="width: ${localVideoWidth}px; height: ${localVideoHeight}px; border: 1px solid black;"></video>
      </div>
      <div style="float:left; margin-left: 20px;">
        <video id="remote-video" autoplay playsinline style="width: ${remoteVideoWidth}px; height: ${remoteVideoHeight}px; border: 1px solid black;"></video>
      </div>
      <!-- <script src="https://cdn.jsdelivr.net/npm/@open-ayame/ayame-web-sdk@2022.1.0/dist/ayame.js"></script> -->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/qs/6.7.0/qs.min.js"></script>
      <script src="./main.js"></script>
      <script type="module">
        import * as Ayame from '@open-ayame/ayame-web-sdk';
        import * as RtcStats from 'rtcstats-wrapper';

        const options = Ayame.defaultOptions;

        options.iceServers = [
        { "urls": "stun:stun.l.google.com:19302" }
        ]

        options.clientId = clientId ? clientId : options.clientId;
        if (signalingKey) {
          options.signalingKey = signalingKey;
        }
        const localVideo = document.querySelector('#local-video');
        const remoteVideo = document.querySelector('#remote-video');
        let conn;
        let mediaStream;

        // smartphoneでは勝手に縦横に対応してくれる
        let videoWidth = 1920;
        let videoHeight = 1080;
        // const videoSizeSelect = document.getElementById('video-size');
        // videoSizeSelect.addEventListener("change", () => {
        //   if (videoSizeSelect.value == "1080p-h") {
        //     videoWidth = 1920;
        //     videoHeight = 1080;
        //   } else if (videoSizeSelect.value == "1080p-v") {
        //     videoWidth = 1080;
        //     videoHeight = 1920;
        //   } else {
        //     videoWidth = 854;
        //     videoHeight = 480;
        //   }
        // }
        // )
        const localVideoWidth = videoWidth;
        const localVideoHeight = videoHeight ;
        const remoteVideoWidth = videoWidth;
        const remoteVideoHeight = videoHeight ;

        document.querySelector("#signalingURLnput").value = signalingUrl;
        document.querySelector("#roomIdInput").value = roomId;
        document.querySelector("#clientIdInput").value = options.clientId;

        // timer
        let connectionStartTime;
        let elapsedTimeInSeconds = 0;
        let elapsedTimeInterval;
        let nowStreaming = false;

        document.getElementById('call-duration').textContent = elapsedTimeInSeconds.toFixed(1);

        function updateElapsedTime() {
          if (nowStreaming) {
            const elapsedTimeInSeconds = (Date.now() - connectionStartTime) / 1000;
            document.getElementById('call-duration').textContent = elapsedTimeInSeconds.toFixed(1);
          }
        }

        // connection
        const connectButton = document.querySelector("#connect");
        const disconnectButton = document.querySelector("#disconnect");

        disconnectButton.addEventListener("click", () => {
          saveMetricsData();
          handleDisconnect();
          handleRecordingOnDisconnect();

          if (nowStreaming) {
            clearInterval(elapsedTimeInterval);
          }
        });

        function handleDisconnect() {
          if (conn) {
            conn.disconnect();
          }
          localVideo.srcObject = null;
          remoteVideo.srcObject = null;
          if (mediaStream) {
            mediaStream.getTracks().forEach((track) => track.stop());
          }
          connectButton.disabled = false
          disconnectButton.disabled = true
        }

        function handleRecordingOnDisconnect() {
          if (mediaRecorderRemote && mediaRecorderRemote.state === 'recording') {
            stopRemoteRecording();
            startRecordingButton.disabled = false;
            stopRecordingButton.disabled = true;
          }
          if (mediaRecorderLocal && mediaRecorderLocal.state === 'recording') {
            stopLocalRecording();
            startRecordingButton.disabled = false;
            stopRecordingButton.disabled = true;
          }
        }

        connectButton.addEventListener("click", async () => {
          connectButton.disabled = true
          disconnectButton.disabled = false

          options.video.codec = "VP9";
          conn = Ayame.connection(signalingUrl, roomId, options, true);
          mediaStream = await navigator.mediaDevices.getUserMedia({
            audio: true,
            video: {
              width: videoWidth,
              height: videoHeight,
            },
          });
          const authnMetadata = {hoge: "fuga"};
          conn.on("open", ({ authzMetadata }) => {
            console.log(authzMetadata);
          });
          conn.on('disconnect', (e) => {
            console.log(e);
            saveMetricsData();
            handleDisconnect();
            handleRecordingOnDisconnect();

            if (nowStreaming) {
              clearInterval(elapsedTimeInterval);
            }
          });
          conn.on('addstream', async (e) => {
            console.log(e.stream);
            remoteVideo.srcObject = e.stream;

            if (!nowStreaming) {
              nowStreaming = true
              connectionStartTime = Date.now();
              elapsedTimeInterval = setInterval(updateElapsedTime, 1000);
            }
          });
          await conn.connect(mediaStream, { authnMetadata });
          localVideo.srcObject = mediaStream;
        });

        // recoding
        const startRecordingButton = document.querySelector("#start-recording");
        const stopRecordingButton = document.querySelector("#stop-recording");

        let mediaRecorderRemote;
        let recordedBlobsRemote;
        const downloadLinkRemote = document.querySelector("#download-link-remote");

        let mediaRecorderLocal;
        let recordedBlobsLocal;
        const downloadLinkLocal = document.querySelector("#download-link-local");

        startRecordingButton.addEventListener("click", () => {
          if (remoteVideo.srcObject) {
            startRemoteRecording();
            startRecordingButton.disabled = true;
            stopRecordingButton.disabled = false;
          }
          if (localVideo.srcObject) {
            startLocalRecording();
            startRecordingButton.disabled = true;
            stopRecordingButton.disabled = false;
          }
          if (!remoteVideo.srcObject && !localVideo.srcObject) {
            alert("fail to start recoding");
          }
        });

        stopRecordingButton.addEventListener("click", () => {
          stopRemoteRecording();
          stopLocalRecording();
          startRecordingButton.disabled = false;
          stopRecordingButton.disabled = true;
        });

        function startRemoteRecording() {
          recordedBlobsRemote = [];
          const mimeType = "video/webm;codecs=VP9,opus";
          const options = { mimeType };

          try {
            mediaRecorderRemote = new MediaRecorder(remoteVideo.srcObject, options);
          } catch (e) {
            console.error("Error creating MediaRecorder:", e);
            return;
          }

          mediaRecorderRemote.ondataavailable = handleRemoteDataAvailable;
          mediaRecorderRemote.onstop = handleRemoteStop;
          mediaRecorderRemote.start();
          console.log("MediaRecorder started:", mediaRecorderRemote);
        }

        function startLocalRecording() {
          recordedBlobsLocal = [];
          const mimeType = "video/webm;codecs=VP9,opus";
          const options = { mimeType };

          try {
            mediaRecorderLocal = new MediaRecorder(localVideo.srcObject, options);
          } catch (e) {
            console.error("Error creating MediaRecorder:", e);
            return;
          }

          mediaRecorderLocal.ondataavailable = handleLocalDataAvailable;
          mediaRecorderLocal.onstop = handleLocalStop;
          mediaRecorderLocal.start();
          console.log("MediaRecorder started:", mediaRecorderLocal);
        }

        function handleRemoteDataAvailable(event) {
          if (event.data && event.data.size > 0) {
            recordedBlobsRemote.push(event.data);
          }
        }

        function handleLocalDataAvailable(event) {
          if (event.data && event.data.size > 0) {
            recordedBlobsLocal.push(event.data);
          }
        }

        function handleRemoteStop() {
          const blob = new Blob(recordedBlobsRemote, { type: "video/webm" });
          const url = window.URL.createObjectURL(blob);
          const dateTime = new Date().toISOString().replace(/[:.]/g, "-");
          downloadLinkRemote.download = `remote-video-${dateTime}.webm`;
          downloadLinkRemote.href = url;
          downloadLinkRemote.style.display = "block";
        }

        function handleLocalStop() {
          const blob = new Blob(recordedBlobsLocal, { type: "video/webm" });
          const url = window.URL.createObjectURL(blob);
          const dateTime = new Date().toISOString().replace(/[:.]/g, "-");
          downloadLinkLocal.download = `local-video-${dateTime}.webm`;
          downloadLinkLocal.href = url;
          downloadLinkLocal.style.display = "block";
        }

        function stopRemoteRecording() {
          mediaRecorderRemote.stop();
        }

        function stopLocalRecording() {
          mediaRecorderLocal.stop();
        }
        // metrics
        let metricsData = []

        async function getInstantaneousLatency() {
          const currentTime = new Date().toISOString();
          if (!conn || conn.connectionState !== "connected") {
            console.error('Connection is not established.');
            return;
          }

          const report = await conn._pc.getStats();

          const types = [
            'remote-inbound-rtp',
            'remote-outbound-rtp',
            'inbound-rtp',
            'outbound-rtp'
          ];

          for (const stat of report.values()) {
            if (types.includes(stat.type)) {
              const statJson = {
                timestamp: currentTime,
                stat: stat,
              };
              metricsData.push(statJson);
            }
          }
        }

        function saveMetricsData() {
          const metricsJson = JSON.stringify(metricsData, null, 2);
          const blob = new Blob([metricsJson], { type: 'application/json;charset=utf-8' });

          // 現在の日時を含めたファイル名を作成
          const currentDateTime = new Date().toISOString().replace(/[:.]/g, '-');
          const fileName = `metrics-${currentDateTime}.txt`;

          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = fileName;

          link.click();
          URL.revokeObjectURL(link.href);
        }

        // 1秒ごとに瞬時遅延を出力
        setInterval(getInstantaneousLatency, 1000);
      </script>
  </body>
</html>
