<html lang="ja">
    <head>
        <meta charset="utf-8">
        <title>Ayame Send/Recv Sample</title>
        <link rel="stylesheet" href="https://cdn.rawgit.com/Chalarangelo/mini.css/v3.0.1/dist/mini-default.min.css">
    </head>
    <body>
      <header class="sticky row">
      <h4>Ayame Send/Recv Sample</h4>
      </header>
      <div>
        <p>Signaling Server
          <input id="signalingURLnput" type="text" value=""></input>
        </p>
        <p>Room ID
        <input id="roomIdInput" type="text"></input>
        </p>
        <p>Client ID
        <input id="clientIdInput" disabled type="text" value=""></input>
        </p>
        <!-- <p> Codec
        <select id="video-codec" onChange="onChangeVideoCodec();">
          <option value="H264">H264</option>
          <option value="none">none</option>
          <option value="VP8">VP8</option>
          <option value="VP9">VP9</option>
          <option value="AV1">AV1</option>
          <option value="H265">H265</option>
        </select>
        </p> -->
        <p> Size
        <select id="video-size">
          <option value="1080p-v">1080p-v</option>
          <option value="1080p-h">1080p-h</option>
          <option value="480p">480p</option>
        </select>
        </p>
        <button id="connect">Connect</button>
        <button id="disconnect" disabled>Disconnect</button>
        <button id="start-recording">Start Recording</button>
        <button id="stop-recording" disabled>Stop Recording</button>
         <a id="download-link" href="#" download="remote-video.webm" style="display:none">Download Recorded Video</a>
      </div>
      <div style="float:left;">
        <video id="local-video" muted autoplay playsinline style="width: ${localVideoWidth}px; height: ${localVideoHeight}px; border: 1px solid black;"></video>
      </div>
      <div style="float:left; margin-left: 20px;">
        <video id="remote-video" autoplay playsinline style="width: ${remoteVideoWidth}px; height: ${remoteVideoHeight}px; border: 1px solid black;"></video>
      </div>
      <!-- <script src="https://cdn.jsdelivr.net/npm/@open-ayame/ayame-web-sdk@2022.1.0/dist/ayame.js"></script> -->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/qs/6.7.0/qs.min.js"></script>
      <script src="./main.js"></script>
      <script type="module">
        import * as Ayame from '@open-ayame/ayame-web-sdk';
        import * as RtcStats from 'rtcstats-wrapper';

        const options = Ayame.defaultOptions;

        options.iceServers = [
        { "urls": "stun:stun.l.google.com:19302" }
        ]

        options.clientId = clientId ? clientId : options.clientId;
        if (signalingKey) {
          options.signalingKey = signalingKey;
        }
        const localVideo = document.querySelector('#local-video');
        const remoteVideo = document.querySelector('#remote-video');
        let conn;
        let mediaStream;

        let videoWidth = 1080;
        let videoHeight = 1920;
        const videoSizeSelect = document.getElementById('video-size');
        videoSizeSelect.addEventListener("change", () => {
          if (videoSizeSelect.value == "1080p-h") {
            videoWidth = 1920;
            videoHeight = 1080;
          } else if (videoSizeSelect.value == "1080p-v") {
            videoWidth = 1080;
            videoHeight = 1920;
          } else {
            videoWidth = 854;
            videoHeight = 480;
          }
        }
        )
        const localVideoWidth = videoWidth;
        const localVideoHeight = videoHeight ;
        const remoteVideoWidth = videoWidth;
        const remoteVideoHeight = videoHeight ;

        document.querySelector("#signalingURLnput").value = signalingUrl;
        document.querySelector("#roomIdInput").value = roomId;
        document.querySelector("#clientIdInput").value = options.clientId;

        // connection
        const connectButton = document.querySelector("#connect");
        const disconnectButton = document.querySelector("#disconnect");

        disconnectButton.addEventListener("click", () => {
          handleDisconnect();
          handleRecordingOnDisconnect();
        });

        function handleDisconnect() {
          if (conn) {
            conn.disconnect();
          }
          localVideo.srcObject = null;
          remoteVideo.srcObject = null;
          if (mediaStream) {
            mediaStream.getTracks().forEach((track) => track.stop());
          }
          connectButton.disabled = false
          disconnectButton.disabled = true
        }

        function handleRecordingOnDisconnect() {
          if (mediaRecorder && mediaRecorder.state === 'recording') {
            stopRecording();
            startRecordingButton.disabled = false;
            stopRecordingButton.disabled = true;
          }
        }

        connectButton.addEventListener("click", async () => {
          connectButton.disabled = true
          disconnectButton.disabled = false

          options.video.codec = "VP9";
          conn = Ayame.connection(signalingUrl, roomId, options, true);
          mediaStream = await navigator.mediaDevices.getUserMedia({
            audio: true,
            video: {
              width: videoWidth,
              height: videoHeight,
            },
          });
          const authnMetadata = {hoge: "fuga"};
          conn.on('open', ({authzMetadata}) => console.log(authzMetadata));
          conn.on('disconnect', (e) => {
            console.log(e);
            handleDisconnect();
            handleRecordingOnDisconnect();
          });
          conn.on('addstream', async (e) => {
            console.log(e.stream);
            remoteVideo.srcObject = e.stream;
          });
          await conn.connect(mediaStream, { authnMetadata });
          localVideo.srcObject = mediaStream;
        });

        // recoding
        let mediaRecorder;
        let recordedBlobs;
        const startRecordingButton = document.querySelector("#start-recording");
        const stopRecordingButton = document.querySelector("#stop-recording");
        const downloadLink = document.querySelector("#download-link");

        startRecordingButton.addEventListener("click", () => {
          if (remoteVideo.srcObject) {
            startRecording(remoteVideo.srcObject);
            startRecordingButton.disabled = true;
            stopRecordingButton.disabled = false;
          } else {
            alert("fail to start recoding");
          }
        });

        stopRecordingButton.addEventListener("click", () => {
          stopRecording();
          startRecordingButton.disabled = false;
          stopRecordingButton.disabled = true;
        });

        function startRecording() {
          recordedBlobs = [];
          const mimeType = "video/webm;codecs=VP9,opus";
          const options = { mimeType };

          try {
            mediaRecorder = new MediaRecorder(remoteVideo.srcObject, options);
          } catch (e) {
            console.error("Error creating MediaRecorder:", e);
            return;
          }

          mediaRecorder.ondataavailable = handleDataAvailable;
          mediaRecorder.onstop = handleStop;
          mediaRecorder.start();
          console.log("MediaRecorder started:", mediaRecorder);
        }

        function handleDataAvailable(event) {
          if (event.data && event.data.size > 0) {
            recordedBlobs.push(event.data);
          }
        }

        function stopRecording() {
          mediaRecorder.stop();
        }

        function handleStop() {
          const blob = new Blob(recordedBlobs, { type: "video/webm" });
          const url = window.URL.createObjectURL(blob);
          const dateTime = new Date().toISOString().replace(/[:.]/g, "-");
          downloadLink.download = `remote-video-${dateTime}.webm`;
          downloadLink.href = url;
          downloadLink.style.display = "block";
        }

        // metrics
        // async function getRtt() {
        //   console.log(conn)
        //   if (!conn || !conn.connectionState == "connected") {
        //     console.error('Connection is not established.');
        //     return;
        //   }
        //   const report = await conn._pc.getStats();
        //   console.log(report)
        //   const rtcStatsMoment = new RtcStats.RTCStatsMoment(conn.connection);

        //   rtcStatsMoment.update(report)
        //   console.log(rtcStatsMoment.report())
        // }

        // setInterval(getRtt, 1000);

        async function getInstantaneousLatency() {
          if (!conn || !conn.connectionState == "connected") {
            console.error('Connection is not established.');
            return;
          }

          const report = await conn._pc.getStats();

          // ビデオとオーディオの瞬時遅延を取得
          const videoInstantaneousLatency = calculateInstantaneousLatency('video', report);
          const audioInstantaneousLatency = calculateInstantaneousLatency('audio', report);

          // コンソールに出力
          console.log(`ビデオの瞬時遅延: ${videoInstantaneousLatency.toFixed(4)} s`);
          console.log(`オーディオの瞬時遅延: ${audioInstantaneousLatency.toFixed(4)} s`);
        }

        function calculateInstantaneousLatency(type, report) {
          let latestTimestamp = 0;
          let instantaneousLatency = 0;

          for (const stat of report.values()) {
            if (stat.type === 'remote-inbound-rtp' && stat.kind === type) {
              if (stat.timestamp > latestTimestamp) {
                latestTimestamp = stat.timestamp;
                instantaneousLatency = stat.roundTripTime;
              }
            }
          }

          return instantaneousLatency;
        }

        // 1秒ごとに瞬時遅延を出力
        setInterval(getInstantaneousLatency, 1000);

      </script>
  </body>
</html>
